
## 00 들어가며
- 소수는 자기자신을 제외한 다른 수로는 나누어 지지 않는 수이다
- 소수를 찾는 공식이 존재하는가? 아니다.
  - * 리만 가설이 이에 대한 가설이고 아직 증명되지 않았다
- 하지만 어떤 수가 주어졌을 때 그 수가 소수가 맞는지 아닌지는 증명할 수 있다.

## 01 브루트포스
- 자기 자신을 제외한 다른 수로 나뉘어지지 않는 수라는 말은 자기 자신을 제외한 모든 수로 나눠서 나눠지지 않으면 소수라는 말이다.
- 그러면 1 부터 자기 자신 까지 모든 수로 나눠보면 된다.

```python
def is_prime(number):
    for divider in range(2, number): # 2부터 n - 1까지의 모든 수
        # 어떤 수로 나눠서 나머지가 0이다? 
        # 어떤 수로 나뉘어 떨어진다는 말이다.
        if number % divider == 0: 
            # 나뉘어 떨어지므로 소수가 아니다
            return False
        # 모든 수에 대해서 나뉘어 떨어지지 않았으므로 소수이다
        return True	
```

### 범위를 줄여보자
- 어떤 수 n에 대해서  $n = a \times b$ 면 소수이다.
  - a < b 일때, a만 검사하면 b에 대해서는 검사 할 필요가 없다.
  - n이 a와 b의 곱이면 a로도 나뉘어지고, b로도 나뉘어 지는 것이다

- 그러면 a의 최댓값을 생각해보자.
  - $n=a\times b$ 이고 $a<b$면 a가 커지면 b는 작아진다.
  - a 가 점점 커져서 $a = b$인 지점이 a의 최댓값이다.
  - 즉, $n = a \times a$ 일때이다.
- 따라서 a의 최댓값은 $\sqrt{n}$ 이다.

- 즉, n의 제곱근까지만 검색해보면 된다. 

```python
def is_prime(number):
    for divider in range(2, sqrt(number)): # 1부터 n의 제곱근까지
        if number % divider == 0: 
            return False
        return True	
```

- 효율적이긴 하지만 여전히 $n \times \sqrt{n}$에 비례하는 시간을 필요로 한다.

- 

## 02 에라토스테네스의 체
- 2의 배수는 적어도 소수는 아니다.
- 3의 배수는 적어도 소수는 아니다.
- ...
- n의 배수는 적어도 소수는 아니다.

- 모든 수의 목록을 준비한다.
- 1을 제외하고 앞에서 부터 목록에 남아 있는 모든 수의 배수를 제외한다.

- 그러면 앞에서부터 제거해 나갈때 남아 있는 수는 무조건 소수인가?
  - 어떤 복합수(소수가 아닌 수) n에 대해서 $n = a \times b$ 이고 $a, b < n$이다.
  - 따라서 복합수는 무조건 자기보다 작은 소수에 의해서 나눠어진다
- 그러므로 자기보다 작은 모든 소수의 배수가 아니다? = 소수다


- 1부터 n까지의 자연수의 집합이 있다고 생각해보자.
```
 1,  2,  3,  4,  5,  6,  7,  8,  9, 10
11, 12, 13, 14, 15, 16, 17, 18, 19, 20
21, 22, 23, 24, 25, 26, 27, 28, 29, 30
31, 32, 33, 34, 35, 36, 37, 38, 39, 40
41, 42, 43, 44, 45, 46, 47, 48, 49, 50
51, 52, 53, 54, 55, 56, 57, 58, 59, 60
61, 62, 63, 64, 65, 66, 67, 68, 69, 70
71, 72, 73, 74, 75, 76, 77, 78, 79, 80
81, 82, 83, 84, 85, 86, 87, 88, 89, 90
91, 92, 93, 94, 95, 96, 97, 98, 99, 100
...
```

- 1은 제외하고, 
```
     2,  3,  4,  5,  6,  7,  8,  9, 10
11, 12, 13, 14, 15, 16, 17, 18, 19, 20
21, 22, 23, 24, 25, 26, 27, 28, 29, 30
31, 32, 33, 34, 35, 36, 37, 38, 39, 40
41, 42, 43, 44, 45, 46, 47, 48, 49, 50
51, 52, 53, 54, 55, 56, 57, 58, 59, 60
61, 62, 63, 64, 65, 66, 67, 68, 69, 70
71, 72, 73, 74, 75, 76, 77, 78, 79, 80
81, 82, 83, 84, 85, 86, 87, 88, 89, 90
91, 92, 93, 94, 95, 96, 97, 98, 99, 100
...
```

- 2로 나누어 떨어지면 적어도 소수는 아니다. 
```
   (2),  3,   ,  5,   ,  7,      9, 
11,   , 13,   , 15,   , 17,   , 19,   
21,   , 23,   , 25,   , 27,   , 29,   
31,   , 33,   , 35,   , 37,   , 39,   
41,   , 43,   , 45,   , 47,   , 49,   
51,   , 53,   , 55,   , 57,   , 59,   
61,   , 63,   , 65,   , 67,   , 69,   
71,   , 73,   , 75,   , 77,   , 79,   
81,   , 83,   , 85,   , 87,   , 89,   
91,   , 93,   , 95,   , 97,   , 99,   
...
```

- 3으로 나누어 떨어지면 적어도 소수가 아니다.
```
     2,(3),   ,  5,   ,  7,   ,   ,
11,   , 13,   ,   ,   , 17,   , 19,   
  ,   , 23,   , 25,   ,   ,   , 29,   
31,   ,   ,   , 35,   , 37,   ,   ,   
41,   , 43,   , 45,   , 47,   , 49,   
  ,   , 53,   , 55,   ,   ,   , 59,   
61,   , 63,   , 65,   , 67,   ,   ,   
71,   , 73,   , 75,   , 77,   , 79,   
  ,   , 83,   , 85,   , 87,   , 89,   
91,   , 93,   , 95,   , 97,   ,   
...
```
.
.
.
- n으로 나누어 떨어지면 적어도 소수가 아니다.
```
     2,  3,   ,   5,   ,  7,   ,   ,
11,   , 13,   ,    ,   , 17,   , 19,   
  ,   , 23,   ,    ,   ,   ,   , 29,   
31,   ,   ,   ,    ,   , 37,   ,   ,   
41,   , 43,   ,    ,   , 47,   ,   ,   
  ,   , 53,   ,    ,   ,   ,   , 59,   
61,   ,   ,   ,    ,   , 67,   ,   ,   
71,   , 73,   ,    ,   ,   ,   , 79,   
  ,   , 83,   ,    ,   ,   ,   , 89,   
  ,   ,   ,   ,    ,   , 97,   ,      
```

따라서 여기에 있는 수는 모두 소수이다.

### 최적화
- n이 소수인지 판별하기 위해서는 n의 제곱근보다 작은 소수에 대해서만 나누면 된다.
- 소수가 숫자를 지울 때는 소수의 제곱보다 큰 수만 지우면 된다.
  - 그 수의 제곱보다 작은 숫자들은 자기보다 작은 소수에 의해서 모두 지워졌기 때문이다

### python

```python
def sieve_of_eratosthenes(target_number):
    # n+1만큼의 배열을 생성 
    # 0을 배열에 포함시켜서 인덱스를 그대로 사용하기 위함
    isPrimes = [True] * (target_number+1)
    
    # 0, 1은 False, 소수가 아님
    isPrimes[0] = False
    isPrimes[1] = False

    
    primes = []

    # n의 제곱근까지만 탐색하면 충분하다
    square_root = int(target_number**(0.5))
  
    # 2에서 n의 제곱근까지 모든 수를 순회
    for number in range(2, square_root + 1):
        # 그 수가 소수라고 표시가 되어 있다면, 
        if isPrimes[number]:
            # number의 배수를 모두 제외
            # umber의 제곱부터
            for i in range(number**2, target_number+1, number):
                isPrimes[i] = False
    
    # 배열의 모든 수를 순회 하면서 소수면 추가.
    for number, isPrime in enumerate(primes):
        if isPrime:
            primes.append(number)

    return primes
```

- 복잡도는 $n*loglog(n)$

## 03 오일러의 채
- 이게 가장 효율적인 방법일까?

- 12의 경우를 보자
  - 2는 소수다. 2, 4, 6, 8, 10, 12, 14 ... 를 지운다
  - 3은 소수다. 3, 6, 9, 12 ... 를 지운다
  - 12는 두번 지워진다. 모든 12의 배수는 2번 이상 지워진다.
- 이걸 없에는 것이 오일러의 채이다.

- 오일러의 채는 i를 고정하고 i와 소수들의 곱을 지운다
- 만약 그 i가 p에 의해서 나눠어 떨어지면 멈추고 i를 키운다.
  - $[p_1,\; p_2,\;p_3,\;...]$이고
  - $i \times p_1 = n$ 을 제거하고 $i \div p_1 = q$면 멈춘다.
  - 안멈출 경우에 $i \times p_2$를 제거하는데 $i\times p_2 = p_1 \times q \times  p_2 =  p_1 \times (q \times p_2)$ 이므로 $p_1$으로 지울 수 있는 숫자를 두번 제거하는 것이다.
  - i는 1씩 꾸준히 증가하므로 반드시 i가 $q \times p_2$가 되는 시점이 존재한다.
  - 직관적으로 p로 나눠는 i가 다른 p와 곱해져서 제거한 결과는 p와 더큰 i와의 곱으로 제거될 결과이기 때문
- 즉 i와 소수의 곱으로 i가 소수에 의해서 나눠지면 멈춘다

### python
```python
def linear_sieve_euler(target_number):
    is_primes = [True] * (target_number + 1)
    
    # 오일러 채는 소수들을 저장해야 함 
    primes = []

    # 2부터 target_number까지 모든 정수 i를 순회
    for i in range(2, target_number + 1):
        # i가 소수라면 목록에 추가
        if is_primes[i]:
            primes.append(i)
        
        # 현재까지 모든 소수를 하나씩 꺼내어 i와 곱함
        for p in primes:
            # 범위를 벗어나면 중단
            if i * p > target_number:
                break
            
            is_primes[i * p] = False
            
            # i가 p의 배수가 되는 순간 멈춤
            # 이 i를 다른 소수와 곱한 결과는 
            # 지금 p와 더 큰 i에 의해서 지워지는 결과이기 때문
            if i % p == 0:
                break

    return primes
```
 
